# 1 "reuse_test/main.cpp"
# 1 "<built-in>" 1
# 1 "<built-in>" 3
# 375 "<built-in>" 3
# 1 "<command line>" 1
# 1 "<built-in>" 2
# 1 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/etc/autopilot_ssdm_op.h" 1
# 158 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/etc/autopilot_ssdm_op.h"
extern "C" {






    void _ssdm_op_IfRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_IfWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_op_IfCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_StreamRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_StreamWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamNbWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned int __attribute__ ((bitwidth(1))) _ssdm_StreamCanWrite(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    unsigned _ssdm_StreamSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_ReadReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Read(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_WriteReq(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Write(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_op_MemShiftRead(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Wait(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_Poll(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_Return(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecSynModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecTopModule(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDecl(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProcessDef(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecConnection(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecChannel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecSensitive(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecModuleInst(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPortMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecReset(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPlatform(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecClockDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecPowerDomain(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecRegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecRegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopName(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecLoopTripCount(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    int _ssdm_op_SpecStateBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    int _ssdm_op_SpecStateEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecInterface(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecDataflowPipeline(...) __attribute__ ((nothrow)) __attribute__((overloadable));


    void _ssdm_op_SpecLatency(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecParallel(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecProtocol(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecOccurrence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecResource(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecResourceLimit(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecCHCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecFUCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIFCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecIPCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecKeepValue(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecMemCore(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecExt(...) __attribute__ ((nothrow)) __attribute__((overloadable));




    void _ssdm_SpecArrayDimSize(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_RegionBegin(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_RegionEnd(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_Unroll(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_UnrollRegion(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_InlineAll(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineLoop(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_Inline(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineSelf(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_InlineRegion(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecArrayMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayPartition(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecArrayReshape(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecStream(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecStable(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecStableContent(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBindPort(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecPipoDepth(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecExpr(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecExprBalance(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecDependence(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecLoopMerge(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopFlatten(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecLoopRewind(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_SpecFuncInstantiation(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncBuffer(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecFuncExtract(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecConstant(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_DataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_SpecDataPack(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void _ssdm_op_SpecBitsMap(...) __attribute__ ((nothrow)) __attribute__((overloadable));
    void _ssdm_op_SpecLicense(...) __attribute__ ((nothrow)) __attribute__((overloadable));

    void __xilinx_ip_top(...) __attribute__ ((nothrow)) __attribute__((overloadable));


}
# 2 "<built-in>" 2
# 1 "reuse_test/main.cpp" 2

# 1 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/hls_stream.h" 1
# 61 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/hls_stream.h"
# 1 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/hls_stream_39.h" 1
# 67 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/hls_stream_39.h"
# 1 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/etc/autopilot_enum.h" 1
# 59 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/etc/autopilot_enum.h"
enum SsdmDataTypes {
    _ssdm_sc_int = 0,
    _ssdm_c_int = _ssdm_sc_int,
    _ssdm_sc_uint = 1,
    _ssdm_c_uint = _ssdm_sc_uint,
    _ssdm_sc_bigint = 2,
    _ssdm_sc_biguint = 3,
};



enum SsdmPortTypes {
    _ssdm_sc_in = 0,
    _ssdm_sc_out = 1,
    _ssdm_sc_inout = 2,
    _ssdm_sc_in_clk,

    _ssdm_fifo_in,
    _ssdm_sc_fifo_in = _ssdm_fifo_in,
    _ssdm_tlm_fifo_in = _ssdm_fifo_in,
    _ssdm_fifo_out,
    _ssdm_sc_fifo_out = _ssdm_fifo_out,
    _ssdm_tlm_fifo_out = _ssdm_fifo_out,
    _ssdm_fifo_inout,
    _ssdm_sc_fifo_inout = _ssdm_fifo_inout,
    _ssdm_tlm_fifo_inout = _ssdm_fifo_inout,
    _ssdm_sc_bus,
    _ssdm_hls_bus_port = _ssdm_sc_bus,
    _ssdm_AXI4M_bus_port = _ssdm_sc_bus,
    _ssdm_port_end,
};



enum SsdmProcessTypes {
    _ssdm_method = 0,
    _ssdm_sc_method = _ssdm_method,
    _ssdm_thread = 1,
    _ssdm_sc_thread = _ssdm_thread,
    _ssdm_cthread = 2,
    _ssdm_sc_cthread = _ssdm_cthread,
    _ssdm_process_end,
};



enum SsdmSensitiveTypes {
    _ssdm_sensitive = 0,
    _ssdm_sensitive_pos,
    _ssdm_sensitive_neg,
    _ssdm_sensitive_reset0,
    _ssdm_sensitive_reset1,
    _ssdm_sensitive_end,
};



enum SsdmChannelTypes {
    _ssdm_sc_sig,
    _ssdm_fifo,
    _ssdm_sc_fifo = _ssdm_fifo,
    _ssdm_mem_fifo,
    _ssdm_sc_mem_fifo = _ssdm_mem_fifo,
};


enum SsdmRegionTypes {
    _ssdm_region_reset,
    _ssdm_region_protocol,
    _ssdm_region_pipeline,
    _ssdm_region_parallel,
};
# 68 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/hls_stream_39.h" 2





namespace hls {
# 95 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/hls_stream_39.h"
template<typename __STREAM_T__, int DEPTH=0>
class stream;

template<typename __STREAM_T__>
class stream<__STREAM_T__, 0>
{
  public:

    inline __attribute__((always_inline)) stream() {
      __fpga_set_stream_depth(&this->V, 0);
    }

    inline __attribute__((always_inline)) stream(const char* name) {
      (void)(name);
      __fpga_set_stream_depth(&this->V, 0);
    }


  private:
    inline __attribute__((always_inline)) stream(const stream< __STREAM_T__ >& chn):V(chn.V) {
    }

    inline __attribute__((always_inline)) stream& operator= (const stream< __STREAM_T__ >& chn) {
        V = chn.V;
        return *this;
    }

  public:

    inline __attribute__((always_inline)) void operator >> (__STREAM_T__& rdata) {
        read(rdata);
    }

    inline __attribute__((always_inline)) void operator << (const __STREAM_T__& wdata) {
        write(wdata);
    }


  public:

    inline __attribute__((always_inline)) bool empty() const {
        return !__fpga_fifo_not_empty(&V);
    }

    inline __attribute__((always_inline)) bool full() const {
        return !__fpga_fifo_not_full(&V);
    }


    inline __attribute__((always_inline)) void read(__STREAM_T__& dout) {
        __fpga_fifo_pop(&V, &dout);
    }


    inline __attribute__((noinline)) bool read_dep(__STREAM_T__& dout, volatile bool flag) {
        __fpga_fifo_pop(&V, &dout);
        return flag;
    }

    inline __attribute__((always_inline)) __STREAM_T__ read() {
        __STREAM_T__ tmp;
        read(tmp);
        return tmp;
    }


    inline __attribute__((always_inline)) bool read_nb(__STREAM_T__& dout) {
        return __fpga_fifo_nb_pop(&V, &dout);
    }


    inline __attribute__((always_inline)) void write(const __STREAM_T__& din) {
        __fpga_fifo_push(&V, &din);
    }


    inline __attribute__((noinline)) bool write_dep(const __STREAM_T__& din, volatile bool flag) {
        __fpga_fifo_push(&V, &din);
        return flag;
    }


    inline __attribute__((always_inline)) bool write_nb(const __STREAM_T__& din) {
        return __fpga_fifo_nb_push(&V, &din);
    }

  public:
    __STREAM_T__ V __attribute__((no_ctor));
};

template<typename __STREAM_T__, int DEPTH>
class stream : public stream<__STREAM_T__, 0> {
  public:
    inline __attribute__((always_inline)) stream() {
      __fpga_set_stream_depth(&this->V, DEPTH);
    }
};
}
# 62 "/home/sumin/tools/Xilinx/Vitis/2020.1/common/technology/autopilot/hls_stream.h" 2
# 3 "reuse_test/main.cpp" 2

typedef struct{
 int data[100];
}buf;

void load_a(volatile int* A, hls::stream<buf>& a_buf_, int tilenuma, int tilen, int n, int numa_iter, int n_iter, int numc_iter) {
#pragma HLS interface ap_ctrl_none port=return


 VITIS_LOOP_12_1: for(int on=0;on<n_iter;on++) {
  VITIS_LOOP_13_2: for(int onc=0;onc<numc_iter;onc++) {
   VITIS_LOOP_14_3: for(int ona=0;ona<numa_iter;ona++) {
 buf a_buf;
 VITIS_LOOP_16_4: for(int i=0;i<tilenuma;i++) {
#pragma HLS loop_tripcount min=4 max=4
 VITIS_LOOP_18_5: for(int j=0;j<tilen;j++) {
#pragma HLS loop_tripcount min=4 max=4
#pragma hls latency min=484 max=484
 int a_buf_ptr = i*tilen+j;
   int A_ptr = (ona*tilenuma+i)*n+(on*tilen+j);
   a_buf.data[a_buf_ptr] = A[A_ptr];
  }
 }
 a_buf_.write(a_buf);
   }
  }
 }
}

void load_b(volatile int* B, hls::stream<buf>& b_buf_, int tilenuma, int tilenumc, int numa, int numc, int numa_iter, int n_iter, int numc_iter) {
#pragma HLS interface ap_ctrl_none port=return

 VITIS_LOOP_35_1: for(int on=0;on<n_iter;on++) {
  VITIS_LOOP_36_2: for(int onc=0;onc<numc_iter;onc++) {
   VITIS_LOOP_37_3: for(int ona=0;ona<numa_iter;ona++) {

  buf b_buf;
  VITIS_LOOP_40_4: for(int i=0;i<tilenuma;i++) {
#pragma HLS loop_tripcount min=4 max=4
 VITIS_LOOP_42_5: for(int j=0;j<tilenumc;j++) {
#pragma HLS loop_tripcount min=4 max=4
#pragma hls latency min=484 max=484
 int b_buf_ptr = i*tilenumc+j;
    int B_ptr = (ona*tilenuma+i)*numc+(onc*tilenumc+j);
    b_buf.data[b_buf_ptr] = B[B_ptr];
   }
  }
  b_buf_.write(b_buf);

   }
  }
 }
}

void store_c(volatile int* C, hls::stream<buf>& c_buf_, int tilenuma, int tilenumc, int tilen, int n, int numa_iter, int n_iter, int numc_iter) {
#pragma HLS interface ap_ctrl_none port=return


 VITIS_LOOP_61_1: for(int on=0;on<n_iter;on++) {
  VITIS_LOOP_62_2: for(int onc=0;onc<numc_iter;onc++) {
   VITIS_LOOP_63_3: for(int ona=0;ona<numa_iter;ona++) {

 if(ona==numa_iter-1) {
 buf c_buf = c_buf_.read();
 VITIS_LOOP_67_4: for(int i=0;i<tilenumc;i++) {
#pragma HLS loop_tripcount min=4 max=4
 VITIS_LOOP_69_5: for(int j=0;j<tilen;j++) {
#pragma HLS loop_tripcount min=4 max=4
#pragma hls latency min=984 max=984
 int c_buf_ptr = i*tilen+j;
   int C_ptr = (onc*tilenumc+i)*n+(on*tilen+j);
   C[C_ptr] += c_buf.data[c_buf_ptr];
  }
 }
 }
   }
  }
 }
}


void conv(hls::stream<buf>& a_buf_, hls::stream<buf>& b_buf_, hls::stream<buf>& c_buf_, int tilen, int tilenuma, int tilenumc, int numa_iter, int n_iter, int numc_iter) {

#pragma HLS interface ap_ctrl_none port=return
 VITIS_LOOP_87_1: for(int on=0;on<n_iter;on++) {
  VITIS_LOOP_88_2: for(int onc=0;onc<numc_iter;onc++) {
   VITIS_LOOP_89_3: for(int ona=0;ona<numa_iter;ona++) {
 static buf a_buf;
 a_buf = a_buf_.read();
 static buf b_buf;

 b_buf = b_buf_.read();
 buf c_buf;
 static int local_c[100];
 VITIS_LOOP_97_4: for(int c=0;c<tilenuma;c++) {
#pragma HLS loop_tripcount min=4 max=4
 VITIS_LOOP_99_5: for(int a=0;a<tilenuma;a++) {
#pragma HLS loop_tripcount min=4 max=4
 VITIS_LOOP_101_6: for(int n=0;n<tilen;n++) {
#pragma HLS loop_tripcount min=4 max=4
#pragma hls latency min=436 max=436
#pragma HLS DEPENDENCE variable=local_c
 int a_buf_ptr = a*tilen+n;
    int b_buf_ptr = a*tilenumc+c;
    int c_buf_ptr = c*tilen+n;
    local_c[c_buf_ptr] += a_buf.data[a_buf_ptr] * b_buf.data[b_buf_ptr];
    c_buf.data[c_buf_ptr] = local_c[c_buf_ptr];
   }
  }
 }
 if(ona==numa_iter-1)
  c_buf_.write(c_buf);
    }
   }
  }
}

__attribute__((sdx_kernel("region", 0))) void region(volatile int* A, volatile int* B, volatile int* C,
  int numa, int numc, int n,
  int tilenuma, int tilenumc, int tilen,
  int numa_iter, int numc_iter, int n_iter) {
#pragma HLS TOP name=region
# 123 "reuse_test/main.cpp"




 hls::stream<buf> a_buf;
 hls::stream<buf> b_buf;
 hls::stream<buf> c_buf;
#pragma HLS STREAM variable=a_buf depth=1
#pragma HLS STREAM variable=b_buf depth=1
#pragma HLS STREAM variable=c_buf depth=1



#pragma HLS stable variable=A
#pragma HLS stable variable=B
#pragma HLS stable variable=C
#pragma HLS dataflow

 load_a(A, a_buf, tilenuma, tilen, n, numa_iter, n_iter, numc_iter);
    load_b(B, b_buf, tilenuma, tilenumc, numa, numc, numa_iter, n_iter, numc_iter);
    conv(a_buf, b_buf, c_buf, tilen, tilenuma, tilenumc, numa_iter, n_iter, numc_iter);
    store_c(C, c_buf, tilenuma, tilenumc, tilen, n, numa_iter, n_iter, numc_iter);



}
